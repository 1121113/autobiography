# settings.py

import pygame

# --- éŠæˆ²æ¿è¨­å®š ---
GRID_WIDTH = 10     # ç¶²æ ¼å¯¬åº¦ (åˆ—æ•¸)
GRID_HEIGHT = 20    # ç¶²æ ¼é«˜åº¦ (è¡Œæ•¸)
BLOCK_SIZE = 30     # æ¯å€‹æ–¹å¡Šçš„åƒç´ å¤§å° (30x30 åƒç´ )

# è¢å¹•å°ºå¯¸
SCREEN_WIDTH = GRID_WIDTH * BLOCK_SIZE + 200  # é¡å¤– 200 åƒç´ ç”¨æ–¼å´é‚Šæ¬„ (åˆ†æ•¸, ä¸‹ä¸€å€‹æ–¹å¡Š)
SCREEN_HEIGHT = GRID_HEIGHT * BLOCK_SIZE

# --- é¡è‰²è¨­å®š (RGB) ---
BLACK = (0, 0, 0)
WHITE = (255, 255, 255)
GRAY = (50, 50, 50)
LIGHT_GRAY = (150, 150, 150)

# æ–¹å¡Šé¡è‰² (å°æ‡‰ä¸ƒç¨® Tetromino)
COLORS = [
    (0, 0, 0),        # 0: ç©ºç™½
    (0, 255, 255),    # 1: I (é’è‰²)
    (255, 165, 0),    # 2: L (æ©™è‰²)
    (0, 0, 255),      # 3: J (è—è‰²)
    (255, 255, 0),    # 4: O (é»ƒè‰²)
    (0, 255, 0),      # 5: S (ç¶ è‰²)
    (128, 0, 128),    # 6: T (ç´«è‰²)
    (255, 0, 0)       # 7: Z (ç´…è‰²)
]

# --- éŠæˆ²é€Ÿåº¦è¨­å®š ---
DROP_DELAY = 1000  # åˆå§‹æ–¹å¡Šè‡ªå‹•ä¸‹è½æ™‚é–“é–“éš” (æ¯«ç§’)
FAST_DROP_DELAY = 50  # æŒ‰ä¸‹å‘ä¸‹éµæ™‚çš„ä¸‹è½é€Ÿåº¦ (æ¯«ç§’)

# --- è¨ˆåˆ†è¨­å®š ---
SCORE_LEVELS = {
    1: 100,
    2: 300,
    3: 500,
    4: 800  # Tetris (å››è¡Œ)
}
# tetris_block.py

import random
from settings import COLORS, GRID_WIDTH, GRID_HEIGHT

# Tetrominoes å½¢ç‹€å®šç¾©ã€‚æ¯å€‹å½¢ç‹€ç”±å››å€‹ç›¸å°åº§æ¨™çµ„æˆã€‚
# (0, 0) æ˜¯æ—‹è½‰ä¸­å¿ƒæˆ–éŒ¨é»ã€‚
SHAPES = {
    # I-Shape (é’)
    'I': [[(0, -1), (0, 0), (0, 1), (0, 2)], 1],
    # L-Shape (æ©™)
    'L': [[(0, -1), (0, 0), (0, 1), (1, 1)], 2],
    # J-Shape (è—)
    'J': [[(0, -1), (0, 0), (0, 1), (-1, 1)], 3],
    # O-Shape (é»ƒ)
    'O': [[(0, 0), (1, 0), (0, 1), (1, 1)], 4],
    # S-Shape (ç¶ )
    'S': [[(0, -1), (0, 0), (1, 0), (1, 1)], 5],
    # T-Shape (ç´«)
    'T': [[(-1, 0), (0, 0), (1, 0), (0, 1)], 6],
    # Z-Shape (ç´…)
    'Z': [[(1, -1), (1, 0), (0, 0), (0, 1)], 7]
}

class TetrisBlock:
    def __init__(self):
        # éš¨æ©Ÿé¸æ“‡ä¸€å€‹æ–¹å¡Šé¡å‹ (ä¾‹å¦‚ 'I', 'L'...)
        self.shape_key = random.choice(list(SHAPES.keys()))
        self.points, self.color_index = SHAPES[self.shape_key]
        self.color = COLORS[self.color_index]
        
        # åˆå§‹ä½ç½®ï¼šx è»¸ç½®ä¸­ï¼Œy è»¸ç½®é ‚
        self.x = GRID_WIDTH // 2 - 1
        self.y = 0

    def get_coords(self):
        """è¨ˆç®—æ–¹å¡Šåœ¨éŠæˆ²æ¿ä¸Šçš„çµ•å°åº§æ¨™ (x, y)"""
        return [(self.x + dx, self.y + dy) for dx, dy in self.points]

    def move(self, dx, dy):
        """ç§»å‹•æ–¹å¡Š"""
        self.x += dx
        self.y += dy

    def rotate(self):
        """æ—‹è½‰æ–¹å¡Š (åƒ… O-Shape ä¸éœ€è¦)"""
        if self.shape_key == 'O':
            return

        # æ—‹è½‰çŸ©é™£: (dx, dy) -> (-dy, dx)
        new_points = []
        for dx, dy in self.points:
            new_points.append((-dy, dx))
        self.points = new_points

    def rotate_back(self):
        """åå‘æ—‹è½‰ï¼Œç”¨æ–¼ç¢°æ’è™•ç† (å¦‚æœæ—‹è½‰å¤±æ•—å‰‡é€€å›)"""
        if self.shape_key == 'O':
            return
            
        # åæ—‹è½‰çŸ©é™£: (dx, dy) -> (dy, -dx)
        new_points = []
        for dx, dy in self.points:
            new_points.append((dy, -dx))
        self.points = new_points

#
# game.py

import pygame
from settings import GRID_WIDTH, GRID_HEIGHT, COLORS, SCORE_LEVELS
from tetris_block import TetrisBlock

class TetrisGame:
    def __init__(self):
        # éŠæˆ²æ¿ï¼šåˆå§‹åŒ–ç‚º GRID_HEIGHT x GRID_WIDTH çš„äºŒç¶­åˆ—è¡¨ï¼Œæ‰€æœ‰å€¼ç‚º 0 (ç©ºç™½)
        self.board = [[0 for _ in range(GRID_WIDTH)] for _ in range(GRID_HEIGHT)]
        self.current_block = TetrisBlock()
        self.next_block = TetrisBlock()
        self.score = 0
        self.level = 1
        self.lines_cleared = 0
        self.game_over = False

    def check_collision(self, block, dx=0, dy=0):
        """æª¢æŸ¥æ–¹å¡Šåœ¨ (dx, dy) ä½ç§»å¾Œæ˜¯å¦æœƒç™¼ç”Ÿç¢°æ’"""
        for x, y in block.get_coords():
            new_x, new_y = x + dx, y + dy

            # 1. ç¢°æ’åˆ°é‚Šç•Œ
            if new_x < 0 or new_x >= GRID_WIDTH or new_y >= GRID_HEIGHT:
                return True
            
            # 2. ç¢°æ’åˆ°é ‚éƒ¨ (åªæª¢æŸ¥æ˜¯å¦è¶…å‡ºéŠæˆ²æ¿ï¼Œä¸è¦–ç‚ºé–å®šç¢°æ’)
            if new_y < 0:
                continue

            # 3. ç¢°æ’åˆ°å·²å›ºå®šçš„æ–¹å¡Š
            if self.board[new_y][new_x] != 0:
                return True
        return False

    def handle_movement(self, dx, dy):
        """è™•ç†æ–¹å¡Šç§»å‹•ï¼Œä¸¦æª¢æŸ¥ç¢°æ’"""
        if not self.game_over:
            if not self.check_collision(self.current_block, dx, dy):
                self.current_block.move(dx, dy)
                return True
        return False

    def handle_rotation(self):
        """è™•ç†æ–¹å¡Šæ—‹è½‰ï¼Œä¸¦æª¢æŸ¥ç¢°æ’"""
        if not self.game_over:
            self.current_block.rotate()
            if self.check_collision(self.current_block):
                # æ—‹è½‰å¾Œç™¼ç”Ÿç¢°æ’ï¼Œå‰‡æ’¤éŠ·æ—‹è½‰
                self.current_block.rotate_back()

    def update(self):
        """éŠæˆ²ä¸»æ›´æ–°é‚è¼¯ï¼šæ–¹å¡Šè‡ªå‹•ä¸‹è½"""
        if self.game_over:
            return

        # å˜—è©¦å‘ä¸‹ç§»å‹•ä¸€æ ¼
        if self.handle_movement(0, 1):
            return

        # å¦‚æœç„¡æ³•ç§»å‹• (ç™¼ç”Ÿç¢°æ’)ï¼Œå‰‡é–å®šæ–¹å¡Š
        self.lock_block()
        
    def lock_block(self):
        """å°‡ç•¶å‰æ´»å‹•æ–¹å¡Šé–å®šåˆ°éŠæˆ²æ¿ä¸Šï¼Œä¸¦æª¢æŸ¥éŠæˆ²çµæŸ"""
        coords = self.current_block.get_coords()
        color_index = self.current_block.color_index
        
        for x, y in coords:
            # æª¢æŸ¥éŠæˆ²æ˜¯å¦çµæŸ (æ–¹å¡Šé–å®šåœ¨é ‚éƒ¨ä¸Šæ–¹)
            if y < 0:
                self.game_over = True
                return
            
            # å°‡æ–¹å¡Šçš„é¡è‰²ç´¢å¼•å¯«å…¥éŠæˆ²æ¿
            if 0 <= y < GRID_HEIGHT and 0 <= x < GRID_WIDTH:
                self.board[y][x] = color_index

        # æ¶ˆé™¤è¡Œä¸¦ç”Ÿæˆæ–°æ–¹å¡Š
        self.clear_lines()
        self.current_block = self.next_block
        self.next_block = TetrisBlock()
        
        # æª¢æŸ¥æ–°æ–¹å¡Šç”Ÿæˆå¾Œæ˜¯å¦ç«‹å³ç¢°æ’ (éŠæˆ²çµæŸæ¢ä»¶)
        if self.check_collision(self.current_block):
            self.game_over = True
            
    def clear_lines(self):
        """æª¢æŸ¥ä¸¦æ¶ˆé™¤å®Œæ•´çš„è¡Œï¼Œæ›´æ–°å¾—åˆ†"""
        rows_to_clear = []
        for i, row in enumerate(self.board):
            # å¦‚æœè¡Œä¸­æ²’æœ‰ 0 (ä»£è¡¨æ²’æœ‰ç©ºç™½ï¼Œè¡Œå·²æ»¿)
            if 0 not in row:
                rows_to_clear.append(i)
        
        num_cleared = len(rows_to_clear)
        if num_cleared > 0:
            # 1. è¨ˆç®—å¾—åˆ†
            points = SCORE_LEVELS.get(num_cleared, 0)
            self.score += points * self.level
            self.lines_cleared += num_cleared
            self.level = 1 + (self.lines_cleared // 10) # æ¯æ¸…é™¤ 10 è¡Œå‡ç´š

            # 2. æ¶ˆé™¤è¡Œï¼šå»ºç«‹ä¸€å€‹æ–°çš„ã€ç©ºçš„éŠæˆ²æ¿
            new_board = [[0 for _ in range(GRID_WIDTH)] for _ in range(GRID_HEIGHT)]
            
            # 3. è¤‡è£½æœªæ¶ˆé™¤çš„è¡Œï¼Œå¾åº•éƒ¨å¾€ä¸Š
            current_row = GRID_HEIGHT - 1
            for row_index in range(GRID_HEIGHT - 1, -1, -1):
                if row_index not in rows_to_clear:
                    new_board[current_row] = self.board[row_index]
                    current_row -= 1
            
            self.board = new_board
            
    def get_drop_coords(self):
        """è¨ˆç®— Ghost Piece (å¹½éˆæ–¹å¡Š) çš„ä½ç½®"""
        block = self.current_block
        dy = 0
        # ä¸æ–·å˜—è©¦å‘ä¸‹ç§»å‹•ï¼Œç›´åˆ°ç¢°æ’ç‚ºæ­¢
        while not self.check_collision(block, 0, dy + 1):
            dy += 1
        
        # è¿”å›å¹½éˆæ–¹å¡Šçš„åº§æ¨™
        return [(x, y + dy) for x, y in block.get_coords()]
              # ğŸ® Tetris ä¿„ç¾…æ–¯æ–¹å¡Š

ä½¿ç”¨ HTML5 Canvas + JavaScript è£½ä½œçš„ç°¡æ˜“ä¿„ç¾…æ–¯æ–¹å¡ŠéŠæˆ²ã€‚

## æ“ä½œæ–¹å¼
- â¬…ï¸ / â¡ï¸ï¼šå·¦å³ç§»å‹•
- â¬†ï¸ï¼šæ—‹è½‰
- â¬‡ï¸ï¼šåŠ é€Ÿä¸‹è½

## åŸ·è¡Œæ–¹å¼
ç›´æ¥ç”¨ç€è¦½å™¨æ‰“é–‹ `index.html`

## Demo
å¯éƒ¨ç½²åˆ° GitHub Pages

